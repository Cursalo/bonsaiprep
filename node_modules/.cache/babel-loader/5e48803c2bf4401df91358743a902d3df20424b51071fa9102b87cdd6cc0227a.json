{"ast":null,"code":"import { supabase } from '../supabaseClient'; // Your Supabase client instance\n\n/**\n * Calls the Supabase Edge Function 'ocr-pdf' to extract text from a PDF.\n * \n * @param fileUrl The publicly accessible URL of the PDF file in Supabase Storage.\n * @param storagePath Alternatively, the path to the file in Supabase Storage (if not using a public URL).\n * @returns A promise that resolves to the extracted text.\n */\nexport const ocrPdfFromSupabase = async (fileUrl, storagePath) => {\n  if (!fileUrl && !storagePath) {\n    throw new Error('Either fileUrl or storagePath must be provided to ocrPdfFromSupabase.');\n  }\n\n  // Construct the body for the function call\n  const body = {};\n  if (fileUrl) body.fileUrl = fileUrl;\n  if (storagePath) body.storagePath = storagePath;\n  const {\n    data,\n    error\n  } = await supabase.functions.invoke('ocr-pdf', {\n    body: body\n  });\n  if (error) {\n    console.error('Error calling ocr-pdf Supabase function:', error);\n    throw new Error(`Failed to process PDF with OCR function: ${error.message}`);\n  }\n  if (!data || !data.extractedText) {\n    console.error('OCR function did not return extracted text:', data);\n    throw new Error('OCR function did not return the expected extractedText field.');\n  }\n  return data.extractedText;\n};\n\n/**\n * Uploads a file to Supabase Storage and returns its public URL or storage path.\n * \n * @param file The file to upload.\n * @param bucketName The name of the Supabase Storage bucket.\n * @param options Optional settings for the upload (e.g., make public, path prefix).\n * @returns A promise that resolves to an object containing the public URL and/or storage path.\n */\nexport const uploadFileToSupabase = async (file, bucketName = 'score-reports',\n// Example bucket name\noptions = {}) => {\n  const {\n    publicAccess = false,\n    pathPrefix = 'uploads'\n  } = options;\n  const fileName = `${pathPrefix}/${Date.now()}-${file.name}`;\n  const {\n    data: uploadData,\n    error: uploadError\n  } = await supabase.storage.from(bucketName).upload(fileName, file, {\n    cacheControl: '3600',\n    upsert: false // true to overwrite if file already exists\n  });\n  if (uploadError) {\n    console.error('Error uploading file to Supabase Storage:', uploadError);\n    throw new Error(`Supabase Storage upload failed: ${uploadError.message}`);\n  }\n  const storagePath = uploadData.path;\n  let publicUrl = undefined;\n  if (publicAccess) {\n    const {\n      data: urlData\n    } = supabase.storage.from(bucketName).getPublicUrl(fileName);\n    publicUrl = urlData === null || urlData === void 0 ? void 0 : urlData.publicUrl;\n  }\n  return {\n    publicUrl,\n    storagePath\n  };\n};","map":{"version":3,"names":["supabase","ocrPdfFromSupabase","fileUrl","storagePath","Error","body","data","error","functions","invoke","console","message","extractedText","uploadFileToSupabase","file","bucketName","options","publicAccess","pathPrefix","fileName","Date","now","name","uploadData","uploadError","storage","from","upload","cacheControl","upsert","path","publicUrl","undefined","urlData","getPublicUrl"],"sources":["/Users/gerardo/Downloads/Bonsaito/src/services/ocrService.ts"],"sourcesContent":["import { supabase } from '../supabaseClient'; // Your Supabase client instance\n\n/**\n * Calls the Supabase Edge Function 'ocr-pdf' to extract text from a PDF.\n * \n * @param fileUrl The publicly accessible URL of the PDF file in Supabase Storage.\n * @param storagePath Alternatively, the path to the file in Supabase Storage (if not using a public URL).\n * @returns A promise that resolves to the extracted text.\n */\nexport const ocrPdfFromSupabase = async (fileUrl?: string, storagePath?: string): Promise<string> => {\n  if (!fileUrl && !storagePath) {\n    throw new Error('Either fileUrl or storagePath must be provided to ocrPdfFromSupabase.');\n  }\n\n  // Construct the body for the function call\n  const body: { fileUrl?: string; storagePath?: string } = {};\n  if (fileUrl) body.fileUrl = fileUrl;\n  if (storagePath) body.storagePath = storagePath;\n\n  const { data, error } = await supabase.functions.invoke('ocr-pdf', {\n    body: body,\n  });\n\n  if (error) {\n    console.error('Error calling ocr-pdf Supabase function:', error);\n    throw new Error(`Failed to process PDF with OCR function: ${error.message}`);\n  }\n\n  if (!data || !data.extractedText) {\n    console.error('OCR function did not return extracted text:', data);\n    throw new Error('OCR function did not return the expected extractedText field.');\n  }\n\n  return data.extractedText;\n};\n\n/**\n * Uploads a file to Supabase Storage and returns its public URL or storage path.\n * \n * @param file The file to upload.\n * @param bucketName The name of the Supabase Storage bucket.\n * @param options Optional settings for the upload (e.g., make public, path prefix).\n * @returns A promise that resolves to an object containing the public URL and/or storage path.\n */\nexport const uploadFileToSupabase = async (\n  file: File,\n  bucketName: string = 'score-reports', // Example bucket name\n  options: { publicAccess?: boolean; pathPrefix?: string } = {}\n): Promise<{ publicUrl?: string; storagePath: string }> => {\n  const { publicAccess = false, pathPrefix = 'uploads' } = options;\n  const fileName = `${pathPrefix}/${Date.now()}-${file.name}`;\n\n  const { data: uploadData, error: uploadError } = await supabase.storage\n    .from(bucketName)\n    .upload(fileName, file, {\n      cacheControl: '3600',\n      upsert: false, // true to overwrite if file already exists\n    });\n\n  if (uploadError) {\n    console.error('Error uploading file to Supabase Storage:', uploadError);\n    throw new Error(`Supabase Storage upload failed: ${uploadError.message}`);\n  }\n\n  const storagePath = uploadData.path;\n  let publicUrl: string | undefined = undefined;\n\n  if (publicAccess) {\n    const { data: urlData } = supabase.storage\n      .from(bucketName)\n      .getPublicUrl(fileName);\n    publicUrl = urlData?.publicUrl;\n  }\n\n  return { publicUrl, storagePath };\n}; "],"mappings":"AAAA,SAASA,QAAQ,QAAQ,mBAAmB,CAAC,CAAC;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,kBAAkB,GAAG,MAAAA,CAAOC,OAAgB,EAAEC,WAAoB,KAAsB;EACnG,IAAI,CAACD,OAAO,IAAI,CAACC,WAAW,EAAE;IAC5B,MAAM,IAAIC,KAAK,CAAC,uEAAuE,CAAC;EAC1F;;EAEA;EACA,MAAMC,IAAgD,GAAG,CAAC,CAAC;EAC3D,IAAIH,OAAO,EAAEG,IAAI,CAACH,OAAO,GAAGA,OAAO;EACnC,IAAIC,WAAW,EAAEE,IAAI,CAACF,WAAW,GAAGA,WAAW;EAE/C,MAAM;IAAEG,IAAI;IAAEC;EAAM,CAAC,GAAG,MAAMP,QAAQ,CAACQ,SAAS,CAACC,MAAM,CAAC,SAAS,EAAE;IACjEJ,IAAI,EAAEA;EACR,CAAC,CAAC;EAEF,IAAIE,KAAK,EAAE;IACTG,OAAO,CAACH,KAAK,CAAC,0CAA0C,EAAEA,KAAK,CAAC;IAChE,MAAM,IAAIH,KAAK,CAAC,4CAA4CG,KAAK,CAACI,OAAO,EAAE,CAAC;EAC9E;EAEA,IAAI,CAACL,IAAI,IAAI,CAACA,IAAI,CAACM,aAAa,EAAE;IAChCF,OAAO,CAACH,KAAK,CAAC,6CAA6C,EAAED,IAAI,CAAC;IAClE,MAAM,IAAIF,KAAK,CAAC,+DAA+D,CAAC;EAClF;EAEA,OAAOE,IAAI,CAACM,aAAa;AAC3B,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,oBAAoB,GAAG,MAAAA,CAClCC,IAAU,EACVC,UAAkB,GAAG,eAAe;AAAE;AACtCC,OAAwD,GAAG,CAAC,CAAC,KACJ;EACzD,MAAM;IAAEC,YAAY,GAAG,KAAK;IAAEC,UAAU,GAAG;EAAU,CAAC,GAAGF,OAAO;EAChE,MAAMG,QAAQ,GAAG,GAAGD,UAAU,IAAIE,IAAI,CAACC,GAAG,CAAC,CAAC,IAAIP,IAAI,CAACQ,IAAI,EAAE;EAE3D,MAAM;IAAEhB,IAAI,EAAEiB,UAAU;IAAEhB,KAAK,EAAEiB;EAAY,CAAC,GAAG,MAAMxB,QAAQ,CAACyB,OAAO,CACpEC,IAAI,CAACX,UAAU,CAAC,CAChBY,MAAM,CAACR,QAAQ,EAAEL,IAAI,EAAE;IACtBc,YAAY,EAAE,MAAM;IACpBC,MAAM,EAAE,KAAK,CAAE;EACjB,CAAC,CAAC;EAEJ,IAAIL,WAAW,EAAE;IACfd,OAAO,CAACH,KAAK,CAAC,2CAA2C,EAAEiB,WAAW,CAAC;IACvE,MAAM,IAAIpB,KAAK,CAAC,mCAAmCoB,WAAW,CAACb,OAAO,EAAE,CAAC;EAC3E;EAEA,MAAMR,WAAW,GAAGoB,UAAU,CAACO,IAAI;EACnC,IAAIC,SAA6B,GAAGC,SAAS;EAE7C,IAAIf,YAAY,EAAE;IAChB,MAAM;MAAEX,IAAI,EAAE2B;IAAQ,CAAC,GAAGjC,QAAQ,CAACyB,OAAO,CACvCC,IAAI,CAACX,UAAU,CAAC,CAChBmB,YAAY,CAACf,QAAQ,CAAC;IACzBY,SAAS,GAAGE,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEF,SAAS;EAChC;EAEA,OAAO;IAAEA,SAAS;IAAE5B;EAAY,CAAC;AACnC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
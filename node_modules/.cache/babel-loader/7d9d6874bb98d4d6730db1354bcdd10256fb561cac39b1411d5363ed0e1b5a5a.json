{"ast":null,"code":"// src/services/aiService.ts\n\n// Define the structure for a generated question\n\n// --- IMPORTANT ---\n// You will need to replace this with your actual Gemini API client setup and API key.\n// Ensure your API key is stored securely, preferably in environment variables.\n// For example: const GEMINI_API_KEY = process.env.REACT_APP_GEMINI_API_KEY;\n\n/**\n * Generates practice questions based on extracted text (identified mistakes) from a PDF.\n * This function is a placeholder and needs to be implemented with actual calls to an AI service like Gemini.\n * \n * @param extractedMistakesText The text extracted from the PDF, focusing on areas identified as mistakes.\n * @returns A promise that resolves to an array of GeneratedQuestion objects.\n */\nexport const generateQuestionsFromMistakes = async extractedMistakesText => {\n  console.log(\"Attempting to generate questions for text:\", extractedMistakesText);\n\n  // --- Placeholder for Gemini API call ---\n  // 1. Initialize your Gemini client here (if not already globally initialized).\n  // 2. Construct a prompt for the Gemini API. The prompt should instruct the AI to:\n  //    - Analyze the provided text (extractedMistakesText).\n  //    - Identify specific topics or concepts where the user made errors.\n  //    - Generate a set of new practice questions (e.g., 3-5 questions) that target these identified weaknesses.\n  //    - Format the questions according to the `GeneratedQuestion` interface (e.g., provide text, topic, and optionally options, answer, explanation).\n  //    - You might want to specify the type of questions (e.g., multiple-choice, short answer).\n  // \n  //    Example Prompt Structure:\n  //    `Based on the following text which describes errors made on a test: \"${extractedMistakesText}\"\n  //     Please generate 3-5 new practice questions. For each question, identify the main topic.\n  //     Return the output as a JSON array of objects, where each object has 'id', 'text', and 'topic' fields.`\n  //\n  // 3. Make the API call to Gemini.\n  // 4. Parse the response from Gemini. Ensure it matches the `GeneratedQuestion[]` structure.\n  //    You might need error handling and type checking for the API response.\n\n  // For now, returning mock data after a delay to simulate API call\n  await new Promise(resolve => setTimeout(resolve, 2000));\n\n  // --- MOCK IMPLEMENTATION START ---\n  // Replace this with actual API call and response parsing.\n  if (!extractedMistakesText || extractedMistakesText.trim() === \"\") {\n    console.warn(\"No text provided for question generation.\");\n    return [];\n  }\n\n  // Simple mock logic based on keywords in the text\n  const mockQuestions = [];\n  const lowercasedText = extractedMistakesText.toLowerCase();\n  if (lowercasedText.includes(\"algebra\")) {\n    mockQuestions.push({\n      id: `alg-${Date.now()}`,\n      text: \"Solve for x: 2x + 5 = 15. (Mock Algebra Question)\",\n      topic: \"Algebra\",\n      options: [\"3\", \"4\", \"5\", \"10\"],\n      answer: \"5\",\n      explanation: \"Subtract 5 from both sides (2x = 10), then divide by 2 (x = 5).\"\n    });\n  }\n  if (lowercasedText.includes(\"reading comprehension\") || lowercasedText.includes(\"passage\")) {\n    mockQuestions.push({\n      id: `rc-${Date.now()}`,\n      text: \"What is the main idea of a paragraph discussing renewable energy? (Mock Reading Question)\",\n      topic: \"Reading Comprehension\"\n    });\n  }\n  if (mockQuestions.length === 0) {\n    mockQuestions.push({\n      id: `gen-${Date.now()}`,\n      text: \"This is a generic mock question as no specific keywords were found in the provided text.\",\n      topic: \"General Knowledge\"\n    });\n  }\n  mockQuestions.push({\n    id: `sum-${Date.now()}`,\n    text: `Based on your report: \"${extractedMistakesText.substring(0, 100)}...\", can you identify one area for improvement? (Mock Summary Question)`,\n    topic: \"Self-Reflection\"\n  });\n  console.log(\"Generated mock questions:\", mockQuestions);\n  return mockQuestions;\n  // --- MOCK IMPLEMENTATION END ---\n};\n\n// Example of how you might call this (for testing purposes):\n/*\n(async () => {\n  const sampleText = \"User made mistakes in Algebra, particularly with quadratic equations. Also struggled with identifying the main idea in a reading passage.\";\n  try {\n    const questions = await generateQuestionsFromMistakes(sampleText);\n    console.log(\"Sample Generated Questions:\", questions);\n  } catch (error) {\n    console.error(\"Error generating sample questions:\", error);\n  }\n})();\n*/","map":{"version":3,"names":["generateQuestionsFromMistakes","extractedMistakesText","console","log","Promise","resolve","setTimeout","trim","warn","mockQuestions","lowercasedText","toLowerCase","includes","push","id","Date","now","text","topic","options","answer","explanation","length","substring"],"sources":["/Users/gerardo/Downloads/Bonsaito/src/services/aiService.ts"],"sourcesContent":["// src/services/aiService.ts\n\n// Define the structure for a generated question\nexport interface GeneratedQuestion {\n  id: string;\n  text: string;         // The question itself\n  topic: string;        // The topic the question relates to (e.g., Algebra, Grammar)\n  difficulty?: string;  // Optional: e.g., Easy, Medium, Hard\n  options?: string[];   // Optional: For multiple-choice questions\n  answer?: string;      // Optional: The correct answer\n  explanation?: string; // Optional: Explanation for the answer\n}\n\n// --- IMPORTANT ---\n// You will need to replace this with your actual Gemini API client setup and API key.\n// Ensure your API key is stored securely, preferably in environment variables.\n// For example: const GEMINI_API_KEY = process.env.REACT_APP_GEMINI_API_KEY;\n\n/**\n * Generates practice questions based on extracted text (identified mistakes) from a PDF.\n * This function is a placeholder and needs to be implemented with actual calls to an AI service like Gemini.\n * \n * @param extractedMistakesText The text extracted from the PDF, focusing on areas identified as mistakes.\n * @returns A promise that resolves to an array of GeneratedQuestion objects.\n */\nexport const generateQuestionsFromMistakes = async (\n  extractedMistakesText: string\n): Promise<GeneratedQuestion[]> => {\n  console.log(\"Attempting to generate questions for text:\", extractedMistakesText);\n\n  // --- Placeholder for Gemini API call ---\n  // 1. Initialize your Gemini client here (if not already globally initialized).\n  // 2. Construct a prompt for the Gemini API. The prompt should instruct the AI to:\n  //    - Analyze the provided text (extractedMistakesText).\n  //    - Identify specific topics or concepts where the user made errors.\n  //    - Generate a set of new practice questions (e.g., 3-5 questions) that target these identified weaknesses.\n  //    - Format the questions according to the `GeneratedQuestion` interface (e.g., provide text, topic, and optionally options, answer, explanation).\n  //    - You might want to specify the type of questions (e.g., multiple-choice, short answer).\n  // \n  //    Example Prompt Structure:\n  //    `Based on the following text which describes errors made on a test: \"${extractedMistakesText}\"\n  //     Please generate 3-5 new practice questions. For each question, identify the main topic.\n  //     Return the output as a JSON array of objects, where each object has 'id', 'text', and 'topic' fields.`\n  //\n  // 3. Make the API call to Gemini.\n  // 4. Parse the response from Gemini. Ensure it matches the `GeneratedQuestion[]` structure.\n  //    You might need error handling and type checking for the API response.\n\n  // For now, returning mock data after a delay to simulate API call\n  await new Promise(resolve => setTimeout(resolve, 2000));\n\n  // --- MOCK IMPLEMENTATION START ---\n  // Replace this with actual API call and response parsing.\n  if (!extractedMistakesText || extractedMistakesText.trim() === \"\") {\n    console.warn(\"No text provided for question generation.\");\n    return [];\n  }\n\n  // Simple mock logic based on keywords in the text\n  const mockQuestions: GeneratedQuestion[] = [];\n  const lowercasedText = extractedMistakesText.toLowerCase();\n\n  if (lowercasedText.includes(\"algebra\")) {\n    mockQuestions.push({\n      id: `alg-${Date.now()}`,\n      text: \"Solve for x: 2x + 5 = 15. (Mock Algebra Question)\",\n      topic: \"Algebra\",\n      options: [\"3\", \"4\", \"5\", \"10\"],\n      answer: \"5\",\n      explanation: \"Subtract 5 from both sides (2x = 10), then divide by 2 (x = 5).\"\n    });\n  }\n  if (lowercasedText.includes(\"reading comprehension\") || lowercasedText.includes(\"passage\")) {\n    mockQuestions.push({\n      id: `rc-${Date.now()}`,\n      text: \"What is the main idea of a paragraph discussing renewable energy? (Mock Reading Question)\",\n      topic: \"Reading Comprehension\",\n    });\n  }\n  if (mockQuestions.length === 0) {\n      mockQuestions.push({\n        id: `gen-${Date.now()}`,\n        text: \"This is a generic mock question as no specific keywords were found in the provided text.\",\n        topic: \"General Knowledge\"\n      });\n  }\n   mockQuestions.push({\n      id: `sum-${Date.now()}`,\n      text: `Based on your report: \"${extractedMistakesText.substring(0, 100)}...\", can you identify one area for improvement? (Mock Summary Question)`,\n      topic: \"Self-Reflection\"\n    });\n\n  console.log(\"Generated mock questions:\", mockQuestions);\n  return mockQuestions;\n  // --- MOCK IMPLEMENTATION END ---\n};\n\n// Example of how you might call this (for testing purposes):\n/*\n(async () => {\n  const sampleText = \"User made mistakes in Algebra, particularly with quadratic equations. Also struggled with identifying the main idea in a reading passage.\";\n  try {\n    const questions = await generateQuestionsFromMistakes(sampleText);\n    console.log(\"Sample Generated Questions:\", questions);\n  } catch (error) {\n    console.error(\"Error generating sample questions:\", error);\n  }\n})();\n*/ "],"mappings":"AAAA;;AAEA;;AAWA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMA,6BAA6B,GAAG,MAC3CC,qBAA6B,IACI;EACjCC,OAAO,CAACC,GAAG,CAAC,4CAA4C,EAAEF,qBAAqB,CAAC;;EAEhF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA,MAAM,IAAIG,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAE,IAAI,CAAC,CAAC;;EAEvD;EACA;EACA,IAAI,CAACJ,qBAAqB,IAAIA,qBAAqB,CAACM,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE;IACjEL,OAAO,CAACM,IAAI,CAAC,2CAA2C,CAAC;IACzD,OAAO,EAAE;EACX;;EAEA;EACA,MAAMC,aAAkC,GAAG,EAAE;EAC7C,MAAMC,cAAc,GAAGT,qBAAqB,CAACU,WAAW,CAAC,CAAC;EAE1D,IAAID,cAAc,CAACE,QAAQ,CAAC,SAAS,CAAC,EAAE;IACtCH,aAAa,CAACI,IAAI,CAAC;MACjBC,EAAE,EAAE,OAAOC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE;MACvBC,IAAI,EAAE,mDAAmD;MACzDC,KAAK,EAAE,SAAS;MAChBC,OAAO,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,CAAC;MAC9BC,MAAM,EAAE,GAAG;MACXC,WAAW,EAAE;IACf,CAAC,CAAC;EACJ;EACA,IAAIX,cAAc,CAACE,QAAQ,CAAC,uBAAuB,CAAC,IAAIF,cAAc,CAACE,QAAQ,CAAC,SAAS,CAAC,EAAE;IAC1FH,aAAa,CAACI,IAAI,CAAC;MACjBC,EAAE,EAAE,MAAMC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE;MACtBC,IAAI,EAAE,2FAA2F;MACjGC,KAAK,EAAE;IACT,CAAC,CAAC;EACJ;EACA,IAAIT,aAAa,CAACa,MAAM,KAAK,CAAC,EAAE;IAC5Bb,aAAa,CAACI,IAAI,CAAC;MACjBC,EAAE,EAAE,OAAOC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE;MACvBC,IAAI,EAAE,0FAA0F;MAChGC,KAAK,EAAE;IACT,CAAC,CAAC;EACN;EACCT,aAAa,CAACI,IAAI,CAAC;IAChBC,EAAE,EAAE,OAAOC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE;IACvBC,IAAI,EAAE,0BAA0BhB,qBAAqB,CAACsB,SAAS,CAAC,CAAC,EAAE,GAAG,CAAC,0EAA0E;IACjJL,KAAK,EAAE;EACT,CAAC,CAAC;EAEJhB,OAAO,CAACC,GAAG,CAAC,2BAA2B,EAAEM,aAAa,CAAC;EACvD,OAAOA,aAAa;EACpB;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
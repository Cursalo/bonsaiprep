{"ast":null,"code":"import{supabase}from'../supabaseClient';// Your Supabase client instance\n/**\n * Calls the Supabase Edge Function 'ocr-pdf' to extract text from a PDF.\n * \n * @param fileUrl The publicly accessible URL of the PDF file in Supabase Storage.\n * @param storagePath Alternatively, the path to the file in Supabase Storage (if not using a public URL).\n * @returns A promise that resolves to the extracted text.\n */export const ocrPdfFromSupabase=async(fileUrl,storagePath)=>{if(!fileUrl&&!storagePath){throw new Error('Either fileUrl or storagePath must be provided to ocrPdfFromSupabase.');}// Construct the body for the function call\nconst body={};if(fileUrl)body.fileUrl=fileUrl;if(storagePath)body.storagePath=storagePath;const{data,error}=await supabase.functions.invoke('ocr-pdf',{body:body});if(error){console.error('Error calling ocr-pdf Supabase function:',error);throw new Error(\"Failed to process PDF with OCR function: \".concat(error.message));}if(!data||!data.extractedText){console.error('OCR function did not return extracted text:',data);throw new Error('OCR function did not return the expected extractedText field.');}return data.extractedText;};/**\n * Uploads a file to Supabase Storage and returns its public URL or storage path.\n * \n * @param file The file to upload.\n * @param bucketName The name of the Supabase Storage bucket.\n * @param options Optional settings for the upload (e.g., make public, path prefix).\n * @returns A promise that resolves to an object containing the public URL and/or storage path.\n */export const uploadFileToSupabase=async function(file){let bucketName=arguments.length>1&&arguments[1]!==undefined?arguments[1]:'score-reports';let options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};const{publicAccess=false,pathPrefix='uploads'}=options;const fileName=\"\".concat(pathPrefix,\"/\").concat(Date.now(),\"-\").concat(file.name);const{data:uploadData,error:uploadError}=await supabase.storage.from(bucketName).upload(fileName,file,{cacheControl:'3600',upsert:false// true to overwrite if file already exists\n});if(uploadError){console.error('Error uploading file to Supabase Storage:',uploadError);throw new Error(\"Supabase Storage upload failed: \".concat(uploadError.message));}const storagePath=uploadData.path;let publicUrl=undefined;if(publicAccess){const{data:urlData}=supabase.storage.from(bucketName).getPublicUrl(fileName);publicUrl=urlData===null||urlData===void 0?void 0:urlData.publicUrl;}return{publicUrl,storagePath};};","map":{"version":3,"names":["supabase","ocrPdfFromSupabase","fileUrl","storagePath","Error","body","data","error","functions","invoke","console","concat","message","extractedText","uploadFileToSupabase","file","bucketName","arguments","length","undefined","options","publicAccess","pathPrefix","fileName","Date","now","name","uploadData","uploadError","storage","from","upload","cacheControl","upsert","path","publicUrl","urlData","getPublicUrl"],"sources":["/Users/gerardo/Downloads/Bonsaito/src/services/ocrService.ts"],"sourcesContent":["import { supabase } from '../supabaseClient'; // Your Supabase client instance\n\n/**\n * Calls the Supabase Edge Function 'ocr-pdf' to extract text from a PDF.\n * \n * @param fileUrl The publicly accessible URL of the PDF file in Supabase Storage.\n * @param storagePath Alternatively, the path to the file in Supabase Storage (if not using a public URL).\n * @returns A promise that resolves to the extracted text.\n */\nexport const ocrPdfFromSupabase = async (fileUrl?: string, storagePath?: string): Promise<string> => {\n  if (!fileUrl && !storagePath) {\n    throw new Error('Either fileUrl or storagePath must be provided to ocrPdfFromSupabase.');\n  }\n\n  // Construct the body for the function call\n  const body: { fileUrl?: string; storagePath?: string } = {};\n  if (fileUrl) body.fileUrl = fileUrl;\n  if (storagePath) body.storagePath = storagePath;\n\n  const { data, error } = await supabase.functions.invoke('ocr-pdf', {\n    body: body,\n  });\n\n  if (error) {\n    console.error('Error calling ocr-pdf Supabase function:', error);\n    throw new Error(`Failed to process PDF with OCR function: ${error.message}`);\n  }\n\n  if (!data || !data.extractedText) {\n    console.error('OCR function did not return extracted text:', data);\n    throw new Error('OCR function did not return the expected extractedText field.');\n  }\n\n  return data.extractedText;\n};\n\n/**\n * Uploads a file to Supabase Storage and returns its public URL or storage path.\n * \n * @param file The file to upload.\n * @param bucketName The name of the Supabase Storage bucket.\n * @param options Optional settings for the upload (e.g., make public, path prefix).\n * @returns A promise that resolves to an object containing the public URL and/or storage path.\n */\nexport const uploadFileToSupabase = async (\n  file: File,\n  bucketName: string = 'score-reports', // Example bucket name\n  options: { publicAccess?: boolean; pathPrefix?: string } = {}\n): Promise<{ publicUrl?: string; storagePath: string }> => {\n  const { publicAccess = false, pathPrefix = 'uploads' } = options;\n  const fileName = `${pathPrefix}/${Date.now()}-${file.name}`;\n\n  const { data: uploadData, error: uploadError } = await supabase.storage\n    .from(bucketName)\n    .upload(fileName, file, {\n      cacheControl: '3600',\n      upsert: false, // true to overwrite if file already exists\n    });\n\n  if (uploadError) {\n    console.error('Error uploading file to Supabase Storage:', uploadError);\n    throw new Error(`Supabase Storage upload failed: ${uploadError.message}`);\n  }\n\n  const storagePath = uploadData.path;\n  let publicUrl: string | undefined = undefined;\n\n  if (publicAccess) {\n    const { data: urlData } = supabase.storage\n      .from(bucketName)\n      .getPublicUrl(fileName);\n    publicUrl = urlData?.publicUrl;\n  }\n\n  return { publicUrl, storagePath };\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}